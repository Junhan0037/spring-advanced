# 스프링 핵심 원리 고급편

## 포인트컷 지시자
포인트컷 표현식은 `execution` 같은 포인트컷 지시자로 시작한다. 줄여서 PCD 라 한다.

- 포인트컷 지시자의 종류
  - `execution`: 메소드 실행 조인 포인트를 매칭한다. 스프링 AOP 에서 가장 많이 사용하고, 기능도 복잡하다.
  - `within`: 특정 타입 내의 조인 포인트를 매칭한다.
  - `args`: 인자가 주언진 타입의 인스턴스인 조인 포인트
  - `this`: 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
  - `target`: Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
  - `@target`: 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
  - `@within`: 주어진 에노테이션이 있는 타입 내 조인 포인트
  - `@annotation`: 메서드가 주언진 에노테이션을 가지고 있는 조인 포인트를 매칭
  - `@args`: 전달된 실제 인수의 런타임 타입이 주어진 타입의 에노테이션을 갖는 조인 포인트
  - `bean`: 스프링 전용 포인트컷 지시자, 진의 이름으로 포인트컷을 지정한다.


## 스프링 AOP 주의사항

### 프록시와 내부 호출 문제
스프링은 프록시 방식의 AOP 를 사용한다.  
따라서 AOP 를 적용하려면 항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다.  
이렇게 해야 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.

**대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다!**  
자바 언어세어 메서드 앞에 별도의 참조가 없으면 `this` 라는 뜻으로 자기 자신의 인스턴스를 가리킨다.  
결과적으로 자신의 내부 메서드를 호출하게 되는데, 여기서 `this` 는 실제 대상 객체(target) 의 인스턴스를 뜻한다.  
이러한 **내부 호출은 프록시를 거치지 않는다.** 따라서 어드바이스를 적용할 수 없다.

#### 해결방법
- 자기 자신을 의존관계 주입 받는 것
- 지연 조회 (`ObjectProvider(Provider)`, `ApplicationContext` 사용)
- 내부 호출이 발생하지 않도록 구조를 변경하는 것 (권장)

### 타입 캐스팅
스프링이 프록시를 만들때 제공하는 `ProxyFactory` 에 `proxyTargetClass` 옵션에 따라 둘중 하나를 선택해서 프록시를 만들 수 있다.

- `proxyTargetClass=false`: JDK 동적 프록시를 사용해서 인터페이스 기반 프록시 생성
- `proxyTargetClass=true`: CGLIB를 사용해서 구체 클래스 기반 프록시 생성
- 참고로 옵션과 무관하게 인터페이스가 없으면 JDK 동적 프록시를 적용할 수 없으므로 CGLIB를 사용한다.

**인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스에 타입 캐스팅이 불가능한 한계가 있다.**

### 의존관계 주입
실제로 개발할 때는 인터페이스가 있으면 인터페이스를 기반으로 의존관계 주입을 받는 것이 맞다.  
DI의 장점이 무엇인가? DI 받는 클라이언트 코드의 변경 없이 구현 클래스를 변경할 수 있는 것이다. 이렇게 하려면 인터페이스를 기반으로 의존관계를 주입 받아야 한다.  
그럼에도 불구하고 테스트, 또는 여러가지 이유로 AOP 프록시가 적용된 구체 클래스를 직접 의존관계 주입 받아야 하는 경우가 있을 수 있다.  
이때는 CGLIB 를 통해 구체 클래스 기반으로 AOP 프록시를 적요하면 된다.

### CGLIB 구체 클래스 기반 프록시 문제점
- 대상 클레스에 기본 생성자 필수
- 생성자 2번 호출 문제
- final 키워드 클래스, 메서드 사용 불가

